export default [
	{
		title: 'Home',
		fileName: 'index.html',
		text: 'Home Project Home Use the apexdox.homePagePath  setting to point to an HTML file that contains details about your project. The body of the HTML will show up here instead of this default!'
	},
	{
		title: 'Log',
		fileName: 'Log.html',
		text: "Log Generic logging framework that persists across DML reversions by publishing a Platform Event Shared Code Signature public with sharing class Log Log Properties Name Signature Description buffer private List<LogMessage> buffer private list of LogMessage objects to be published in the future currentInstance private static Log currentInstance private instance of this log class that backs the singleton get() method. Log Constructors Log() establishes the buffer, if one doesn't yet exist private, to ensure we can't directly construct this class. Use the Singleton, Luke. Log() establishes the buffer, if one doesn't yet exist private, to ensure we can't directly construct this class. Use the Singleton, Luke. Signature private Log() Log Methods add(messageToLog) Add a message to the buffer without publishing it. Assumes a null severity add(messageToLog, severity) Add a message to the buffer without publishing it. add(exceptionToLog) Add an formatted exception message to the buffer without publishing it. Assumes a null Severity add(exceptionToLog, severity) Add an formatted exception message to the buffer without publishing it. get() Singleton pattern get  method. publish() Publish any messages currently in the buffer, without adding any new ones. publish(exceptionToLog) Auto-format exception details, add it to the log buffer, and then publish the current buffer. Use the equivalent add method if you intend to add multiple messages rapidly to minimize DML usage. publish(messageToLog) Auto-format a custom log message string, add it to the log buffer, and then publish the current buffer. Use the equivalent add method if you intend to add multiple messages rapidly to minimize DML usage. add(messageToLog) Add a message to the buffer without publishing it. Assumes a null severity Signature public void add(String messageToLog) Parameters messageToLog Type: String The string message to add to the buffer. add(messageToLog, severity) Add a message to the buffer without publishing it. Signature public void add(String messageToLog, LogMessage.LogSeverity severity) Parameters messageToLog Type: String The string message to add to the buffer. severity Type: LogMessage.LogSeverity LogMessage.LogSeverity enum add(exceptionToLog) Add an formatted exception message to the buffer without publishing it. Assumes a null Severity Signature public void add(Exception exceptionToLog) Parameters exceptionToLog Type: Exception Exception to format and log add(exceptionToLog, severity) Add an formatted exception message to the buffer without publishing it. Signature public void add(Exception exceptionToLog, LogMessage.LogSeverity severity) Parameters exceptionToLog Type: Exception Exception to format and log severity Type: LogMessage.LogSeverity LogMessage.LogSeverity enum get() Singleton pattern get  method. Signature public static Log get() Returns Log publish() Publish any messages currently in the buffer, without adding any new ones. Signature public void publish() publish(exceptionToLog) Auto-format exception details, add it to the log buffer, and then publish the current buffer. Use the equivalent add method if you intend to add multiple messages rapidly to minimize DML usage. Signature public void publish(Exception exceptionToLog) Parameters exceptionToLog Type: Exception exception to format and log publish(messageToLog) Auto-format a custom log message string, add it to the log buffer, and then publish the current buffer. Use the equivalent add method if you intend to add multiple messages rapidly to minimize DML usage. Signature public void publish(String messageToLog) Parameters messageToLog Type: String String to log"
	},
	{
		title: 'LogMessage',
		fileName: 'LogMessage.html',
		text: 'LogMessage A class for automatically attaching metadata to log messages like Quiddity and RequestID Shared Code Signature public with sharing class LogMessage LogMessage Properties Name Signature Description EXCEPTION_STRING_FORMAT private static final String EXCEPTION_STRING_FORMAT message public String message Public message property. quiddity public Quiddity quiddity Public read only property for quiddity. Privately set. requestId public String requestId public read only property for the request ID. Privately set. set private set set private set severity public LogSeverity severity Public severity property. Enums Name Signature Values Description LogSeverity public enum LogSeverity DEBUG, INFO, WARN, ERROR A severity enum for Log, and LogMessage to use. LogMessage Constructors LogMessage(message) Constructor accepting a message to log. Severity is auto set to info LogMessage(ex) Constructor accepting an exception object. LogMessage(message) Constructor accepting a message to log. Severity is auto set to info Signature public LogMessage(String message) Parameters message Type: String LogMessage(ex) Constructor accepting an exception object. Signature public LogMessage(Exception ex) Parameters ex Type: Exception LogMessage Methods toEvent() converts this object to an event for publishing toEvent() converts this object to an event for publishing Signature public Log__e toEvent() Returns SObject'
	},
	{
		title: 'OrgShape',
		fileName: 'OrgShape.html',
		text: "OrgShape Class contains static methods for determining if specific platform features are enabled. For example, do we have platform cache enabled. You could also write similar methods for experiences. Shared Code Signature public with sharing class OrgShape OrgShape Properties Name Signature Annotations Description DEFAULTPARTITION private static final String DEFAULTPARTITION Defines the default cache partition for use in this class. getFiscalYearStartMonth public Integer getFiscalYearStartMonth returns this org's fiscal year starting month hasNamespacePrefix public Boolean hasNamespacePrefix reports whether this transaction took place in an org with a namespace prefix id public Id id reports the org's ID. in practice, this is a constant instanceName public String instanceName returns the instance name. In practice not null. isReadOnly public Boolean isReadOnly reports the read-only status. this is a proxy for 'is this org active' isSandbox public Boolean isSandbox property reports whether this transaction took place in a sandbox. lightningEnabled public Boolean lightningEnabled reports the users' displayed theme. locale public String locale reports the org's locale multiCurrencyEnabled public Boolean multiCurrencyEnabled reports whether or not this transaction took place in an org with multiCurrency enabled. Note: I have no idea why the underlying method is on UserInfo. name public String name reports the org's name namespacePrefix public String namespacePrefix reports the namespace prefix of this org. May return null; orgShape private Organization orgShape @TestVisible orgType public String orgType reports this org's type. ie: 'Developer Edition' podName public String podName convenience method. Alias for instanceName safeDefaultCachePartition private Cache.OrgPartition safeDefaultCachePartition @TestVisible set private set timeZoneKey public String timeZoneKey reports the timeZoneSidKey Enums Name Signature Values Description PartitionType public enum PartitionType SESSION, ORG Enum for partition type. OrgShape Methods getAvailableOrgCachePartition() This method is responsible for discovering a cache partition that can be used for determining if platformCache is enabled and configured. Note: This method memoizes the result of the query, ensuring that the underlying soql query is only ever run once per transaction. getDefaultPartition(type) returns a Cache.Partition for a given name, and type getOrgRecord() Private method for pulling the Organization record Note: We're suppressing PMD warning on Crud Checking because we want everyone to be able to pull this read-only record. getOrgShape() Private method that memoizes the query result Suppressing the PMD warning to validate crud permissions before DML, because the Organization Object is always available. isAdvancedMultiCurrencyManagementEnabled() Uses a dynamic soql query to determine if Advanced MultiCurrency Management is enabled. Note, this must be a dynamic soql query because referencing DatedConversionRate will not compile in orgs without Advanced MultiCurrency Management enabled. Note: This was originally written by the NPSP team and can be found here: https://github.com/SalesforceFoundation/NPSP/blob/aad20ffb747ecda9a037c4bce9cd19617b6a727b/src/classes/UTIL_Currency.cls#L79 isPlatformCacheEnabled() Method determines if platform cache is enabled for this org Note: fail-safes to false. Note: Allows override by setting OrgShape.disablePlatformCache equal to true. Use this in test contexts where cache is not available like when you have to use seeAllData=true isSeeAllDataTrue() Certain features of the platform are incompatible with data-siloed tests. These features require testing with the annotation @test(seeAllData=true). Other platform features are incompatible with seeAllData=true. When used in a test context, this method determines if the currently running test is executing with, or without seeAllData=true. This method is therefore used to automatically disable platform features that require are incompatible with seeAllData=true. For example: platform cache is incompatible with seeAllData=true. However, our security library, CanTheUser utilizes platform cache to accelerate Crud and FLS checks. CanTheUser uses this method, in part, to determine, transparently if it should utilize platformCache during test execution Note: It is not a good idea, and against best practices to use seeAllData=true when not absolutely necessary. getAvailableOrgCachePartition() This method is responsible for discovering a cache partition that can be used for determining if platformCache is enabled and configured. Note: This method memoizes the result of the query, ensuring that the underlying soql query is only ever run once per transaction. Signature @SuppressWarnings('PMD.ApexCRUDViolation') private Cache.OrgPartition getAvailableOrgCachePartition() Returns String getDefaultPartition(type) returns a Cache.Partition for a given name, and type Signature public Cache.Partition getDefaultPartition(PartitionType type) Parameters type Type: PartitionType Enum of .SESSION or .ORG Returns Cache.Partition getOrgRecord() Private method for pulling the Organization record Note: We're suppressing PMD warning on Crud Checking because we want everyone to be able to pull this read-only record. Signature private Organization getOrgRecord() getOrgShape() Private method that memoizes the query result Suppressing the PMD warning to validate crud permissions before DML, because the Organization Object is always available. Signature @SuppressWarnings('PMD.ApexCRUDViolation') private Organization getOrgShape() Returns Organization isAdvancedMultiCurrencyManagementEnabled() Uses a dynamic soql query to determine if Advanced MultiCurrency Management is enabled. Note, this must be a dynamic soql query because referencing DatedConversionRate will not compile in orgs without Advanced MultiCurrency Management enabled. Note: This was originally written by the NPSP team and can be found here: https://github.com/SalesforceFoundation/NPSP/blob/aad20ffb747ecda9a037c4bce9cd19617b6a727b/src/classes/UTIL_Currency.cls#L79 Signature @SuppressWarnings('PMD.EmptyCatchBlock') public Boolean isAdvancedMultiCurrencyManagementEnabled() Returns Boolean isPlatformCacheEnabled() Method determines if platform cache is enabled for this org Note: fail-safes to false. Note: Allows override by setting OrgShape.disablePlatformCache equal to true. Use this in test contexts where cache is not available like when you have to use seeAllData=true Signature public Boolean isPlatformCacheEnabled() Returns Boolean isSeeAllDataTrue() Certain features of the platform are incompatible with data-siloed tests. These features require testing with the annotation @test(seeAllData=true). Other platform features are incompatible with seeAllData=true. When used in a test context, this method determines if the currently running test is executing with, or without seeAllData=true. This method is therefore used to automatically disable platform features that require are incompatible with seeAllData=true. For example: platform cache is incompatible with seeAllData=true. However, our security library, CanTheUser utilizes platform cache to accelerate Crud and FLS checks. CanTheUser uses this method, in part, to determine, transparently if it should utilize platformCache during test execution Note: It is not a good idea, and against best practices to use seeAllData=true when not absolutely necessary. Signature public Boolean isSeeAllDataTrue() Returns Boolean OrgShape.CachedOrgShape Signature public with sharing class CachedOrgShape implements Cache.CacheBuilder OrgShape.CachedOrgShape Methods doLoad(requiredButNotUsed) Note: We're suppressing PMD warning on Crud Checking because we want everyone to be able to pull this read-only record. doLoad(requiredButNotUsed) Note: We're suppressing PMD warning on Crud Checking because we want everyone to be able to pull this read-only record. Signature public Organization doLoad(String requiredButNotUsed)"
	},
	{
		title: 'Ouroboros',
		fileName: 'Ouroboros.html',
		text: 'Ouroboros Signature public with sharing abstract class Ouroboros implements Queueable, Database.AllowsCallouts Ouroboros Properties Name Signature passthrough public Object passthrough Ouroboros Methods className() execute() execute(context) hasExitCriteriaBeenMet() className() Signature public String className() execute() Signature abstract public void execute() execute(context) Signature public virtual void execute(QueueableContext context) hasExitCriteriaBeenMet() Signature abstract public boolean hasExitCriteriaBeenMet()'
	},
	{
		title: 'OuroborosFinalizer',
		fileName: 'OuroborosFinalizer.html',
		text: 'OuroborosFinalizer Signature public with sharing class OuroborosFinalizer implements Finalizer OuroborosFinalizer Properties Name Signature logger private Log logger ouroboros private Ouroboros ouroboros OuroborosFinalizer Constructors OuroborosFinalizer(ouroboros) OuroborosFinalizer(ouroboros) Signature public OuroborosFinalizer(Ouroboros ouroboros) OuroborosFinalizer Methods execute(context) safeToEnqueueAccordingToLimits() execute(context) Signature public void execute(FinalizerContext context) safeToEnqueueAccordingToLimits() Signature private boolean safeToEnqueueAccordingToLimits()'
	},
	{
		title: 'OuroborosTests',
		fileName: 'OuroborosTests.html',
		text: 'OuroborosTests Signature @isTest class OuroborosTests OuroborosTests Properties Name Signature codeDidTryToReEnqueue private Boolean codeDidTryToReEnqueue OuroborosTests Methods testOuroborosFunctionalNegative() testOuroborosFunctionalNegative() Signature @isTest static void testOuroborosFunctionalNegative() OuroborosTests.ExampleOuroborosImplementation Signature public class ExampleOuroborosImplementation extends Ouroboros OuroborosTests.ExampleOuroborosImplementation Methods execute() hasExitCriteriaBeenMet() execute() Signature public override void execute() hasExitCriteriaBeenMet() Signature public override Boolean hasExitCriteriaBeenMet()'
	},
	{
		title: 'Polyfills',
		fileName: 'Polyfills.html',
		text: 'Polyfills Signature public with sharing class Polyfills Polyfills Methods classNameFromInstance(obj) getSObjectTypeFromList(sObjects) idMapFromCollectionByKey(key, incomingList) mapFromCollectionWithCollectionValues(key, incomingList) stringMapFromCollectionByKey(key, incomingList) typeObjectFromClassName(className) typeObjFromInstance(obj) classNameFromInstance(obj) Signature public static String classNameFromInstance(Object obj) getSObjectTypeFromList(sObjects) Signature public static String getSObjectTypeFromList(List<SObject> sObjects) idMapFromCollectionByKey(key, incomingList) Signature public static Map<Id, SObject> idMapFromCollectionByKey(\t\tString key,\t\tList<SObject> incomingList\t) mapFromCollectionWithCollectionValues(key, incomingList) Signature public static Map<Id, List<SObject>> mapFromCollectionWithCollectionValues(\t\tString key,\t\tList<SObject> incomingList\t) stringMapFromCollectionByKey(key, incomingList) Signature public static Map<String, SObject> stringMapFromCollectionByKey(\t\tString key,\t\tList<SObject> incomingList\t) typeObjectFromClassName(className) Signature public static Type typeObjectFromClassName(String className) typeObjFromInstance(obj) Signature public static Type typeObjFromInstance(Object obj) Polyfills.GuaranteedNotToExist Signature private class GuaranteedNotToExist'
	},
	{
		title: 'TestPolyfills',
		fileName: 'TestPolyfills.html',
		text: 'TestPolyfills Signature @isTest public with sharing class TestPolyfills TestPolyfills Properties Name Signature circuitBreakerTripped public static Boolean circuitBreakerTripped'
	},
	{
		title: 'Chain',
		fileName: 'Chain.html',
		text: "Chain This class implements the Apex Transaction Finalizer interface. It's used to implement promises. This class is constructed with a list of Promise Objects, and any passthrough data. The first promise in the list is executed. The Promise implementing class automatically attaches this finalizer to it's execution. Signature public class Chain implements Finalizer Chain Constructors Chain(promises, passthrough) Chain(promises, passthrough) Signature public Chain(Promise[] promises, Object passthrough) Chain Methods execute(context) execute(context) Signature public void execute(FinalizerContext context)"
	},
	{
		title: 'Promise',
		fileName: 'Promise.html',
		text: "Promise This class provides an implementation of the Promise pattern. The promise pattern allows developers to have asynchronous flow control without the need to handle callbacks. Developers will extend this class, implementing the necessary execute  method. The contents of your execute method will be executed asynchronously. Using the then  method of this class, you can construct chains of asynchronous operations. As each 'step' of the chain is completed the transaction finalizer will be constructed with the remaining steps and any passthrough data you specify. Passthrough data allows you to pass data between steps. Signature public abstract class Promise implements Queueable, Database.AllowsCallouts Promise Properties Name Signature passthrough public Object passthrough promises public List<Promise> promises Promise Methods execute() execute(context) then(toAdd) execute() Signature abstract public void execute() execute(context) Signature public virtual void execute(QueueableContext context) then(toAdd) Signature protected Promise then(object toAdd)"
	},
	{
		title: 'QuiddityGuard',
		fileName: 'QuiddityGuard.html',
		text: 'QuiddityGuard contains methods and static lists for rapid acceptence of a particular set of quiddities Signature public with sharing class QuiddityGuard QuiddityGuard Properties Name Signature Annotations Description testQuiddityOverride private static Quiddity testQuiddityOverride @TestVisible a private testvisible variable allowing developers to inject a custom quiddity value during test execution. trustedQuiddities public static List<Quiddity> trustedQuiddities a non-exhaustive list of Quiddities that do not include user situations where users could be injecting malicious data. trustedTestQuiddities public static List<Quiddity> trustedTestQuiddities An exaustive list of quiddities that are valid for a test execution untrustedQuiddities public static List<Quiddity> untrustedQuiddities A list of quiddities that may include user-defined data and therefore should not be trusted without manual FLS/CRUD checks QuiddityGuard Methods isAcceptableQuiddity(acceptableQuiddites) A method to determine if the current Quiddity context is within a caller-supplied list of acceptable quiddity values. isNotAcceptableQuiddity(acceptableQuiddites) quiddity() quiddityIsATestContext() isAcceptableQuiddity(acceptableQuiddites) A method to determine if the current Quiddity context is within a caller-supplied list of acceptable quiddity values. Signature public static Boolean isAcceptableQuiddity(\t\tList<Quiddity> acceptableQuiddites\t) Parameters acceptableQuiddites Type: \t\tList<Quiddity> A list of quiddities to check against Returns boolean isNotAcceptableQuiddity(acceptableQuiddites) Signature public static Boolean isNotAcceptableQuiddity(\t\tList<Quiddity> acceptableQuiddites\t) quiddity() Signature public static Quiddity quiddity() quiddityIsATestContext() Signature public static Boolean quiddityIsATestContext()'
	},
	{
		title: 'CanTheUser',
		fileName: 'CanTheUser.html',
		text: "CanTheUser A reusable, intuitive library for determining wether or not the current use can create, read, edit, or delete objects as well as determining if the user has access or update permissions on specific fields. This class name was chosen to facilitate easy-to-understand and read code. Whenever you need to check FLS or CRUD access your code reads like this if(CanTheUser.read(new account())){}  making the calling and use of this code easy and intuitive. Signature public with sharing class CanTheUser CanTheUser Properties Name Signature Annotations accessibleFieldsByObject private static Map<String, Set<String>> accessibleFieldsByObject @testVisible updatableFieldsByObject private static Map<String, Set<String>> updatableFieldsByObject @testVisible Enums Name Signature Values CrudType public enum CrudType CREATE, READ, EDIT, DEL, UPS FLSType public enum FLSType ACCESSIBLE, UPDATABLE CanTheUser Methods getFLSForFieldOnObject(obj, field, checkType) Abstracted method for retrieving or calculating(memoization) of the FLS for a given field on a given object. memoizeFLSMDC(objType, action) Utilizes the Metadata catalog to determine FLS Note: this method contains a false-positive PMD violation. Normally, we'd want to check for FLS/CRUD here, but for metadata catalog objects that admins cannot remove permissions to we're ok. Additionally, even the minimum access profile user has read access to the FieldPermissions object. getFLSForFieldOnObject(obj, field, checkType) Abstracted method for retrieving or calculating(memoization) of the FLS for a given field on a given object. Signature private static Boolean getFLSForFieldOnObject(\t\tString obj,\t\tString field,\t\tFLSType checkType\t) Parameters obj Type: \t\tString String version of object name to check field     String version of the field to check checkType Enum of Accessible or Updatable. Returns Boolean memoizeFLSMDC(objType, action) Utilizes the Metadata catalog to determine FLS Note: this method contains a false-positive PMD violation. Normally, we'd want to check for FLS/CRUD here, but for metadata catalog objects that admins cannot remove permissions to we're ok. Additionally, even the minimum access profile user has read access to the FieldPermissions object. Signature @testVisible private static Set<String> memoizeFLSMDC(String objType, FLSType action) Parameters objType Type: String String version of the object type to check action Type: FLSType Enum of the FLS action to check permissions for Returns set<String> CanTheUser.CanTheUserException Internal custom exception class Signature public class CanTheUserException extends Exception CanTheUser.PermissionCache this cachebuilder interface allows the CanTheUser class to cache per-object results for each object requested. This prevents the need to repeatedly calculate permission usage by calling Schema.Describe* calls Signature private class PermissionCache implements Cache.CacheBuilder CanTheUser.PermissionCache Methods bulkFLSAccessible(obj, fields) bulk form of flsAccessible bulkFLSUpdatable(obj, fields) bulk form of flsUpdatable call calculateFLS(objType) Calculates the FLS for a given object type create(obj) convenience api for determining if the running user can create the specified object create(objs) convenience api for determining if the running user can create the specified object create(objName) convenience api for determining if the running user can create the specified object crud(obj, permission) This class' name was chosen to facilitate easy-to-understand and read code. Whenever you need to check FLS or CRUD access your code reads like this if(CanTheUser.read(new account())){}  making the calling and use of this code easy and intuitive. crud(objs, permission) crud(objectName, permission) destroy(obj) convenience api for determining if the running user can delete/destroy the specified object destroy(objs) convenience api for determining if the running user can delete the specified object destroy(objName) convenience api for determining if the running user can delete the specified object doLoad(objType) Required method for the CacheBuilder interface. Used here to either calculate an objects per-user FLS, OR to return it from Cache. The return datastructure for this is Map<String, Map<FLSType,Boolean>> and represents: FieldName -> FLStype -> True/False edit(obj) convenience api for determining if the running user can edit / update the specified object edit(objs) convenience api for determining if the running user can edit / update the specified objects edit(objName) convenience api for determining if the running user can edit the specified object flsAccessible(obj, field) public method to determine if a given field on a given object is Accessible(readable) flsUpdatable(obj, field) public method to determine if a given field on a given object is Updatable. read(obj) convenience api for determining if the running user can read / access the specified object read(objs) convenience api for determining if the running user can read / access the specified objects read(objName) convenience api for determining if the running user can read the specified object ups(obj) convenience api for determining if the running user can upsert(insert and update) the specified objects ups(objs) convenience api for determining if the running user can edit / update the specified objects ups(objName) convenience api for determining if the running user can upsert the specified object bulkFLSAccessible(obj, fields) bulk form of flsAccessible Signature public static Map<String, Boolean> bulkFLSAccessible(\t\tString obj,\t\tSet<String> fields\t) Parameters obj Type: \t\tString Obj name on which to check fields Set of Fields to check for accessibility. Returns Map<String, Boolean> Example String[] fields = new String[]{'Name', 'ShippingStreet'}; System.debug(CanTheUser.bulkFLSAccessible('Account', fields)); bulkFLSUpdatable(obj, fields) bulk form of flsUpdatable call Signature public static Map<String, Boolean> bulkFLSUpdatable(\t\tString obj,\t\tSet<String> fields\t) Parameters obj Type: \t\tString Name of the object fields Set of Field names to check Returns Map<String, Boolean> Example String[] fields = new String[]{'Name', 'ShippingStreet'}; System.debug(CanTheUser.bulkFLSUpdatable('Account', fields)); calculateFLS(objType) Calculates the FLS for a given object type Signature public Map<String, Map<FLSType, Boolean>> calculateFLS(string objType) Parameters objType Type: string String name of the object type Returns Map<String, Map<FLSType, Boolean>> create(obj) convenience api for determining if the running user can create the specified object Signature public static Boolean create(SObject obj) Parameters obj Type: SObject Object type to check create permissions on Returns Boolean Example System.debug(CanTheUser.create(new Account())); create(objs) convenience api for determining if the running user can create the specified object Signature public static Boolean create(List<SObject> objs) Parameters objs Type: List<SObject> list of objects. Only the first will be checked.(logically, a list is of uniform type and, and if the user can create one) Returns Boolean create(objName) convenience api for determining if the running user can create the specified object Signature public static Boolean create(String objName) Parameters String Object type to check create permissions on Returns Boolean Example System.debug(CanTheUser.create('Account')); crud(obj, permission) This class' name was chosen to facilitate easy-to-understand and read code. Whenever you need to check FLS or CRUD access your code reads like this if(CanTheUser.read(new account())){}  making the calling and use of this code easy and intuitive. Signature public static Boolean crud(SObject obj, CrudType permission) crud(objs, permission) Signature @testVisible private static Boolean crud(List<SObject> objs, CrudType permission) crud(objectName, permission) Signature @testVisible private static Boolean crud(String objectName, CrudType permission) destroy(obj) convenience api for determining if the running user can delete/destroy the specified object Signature public static Boolean destroy(SObject obj) Parameters obj Type: SObject object type to check destroy permissions on Returns Boolean Example System.debug(CanTheUser.destroy(new Account())); destroy(objs) convenience api for determining if the running user can delete the specified object Signature public static Boolean destroy(List<SObject> objs) Parameters String Object type to check delete permissions on Returns Boolean destroy(objName) convenience api for determining if the running user can delete the specified object Signature public static Boolean destroy(String objName) Parameters String Object type to check create permissions on Returns Boolean Example System.debug(CanTheUser.destroy('Account')); doLoad(objType) Required method for the CacheBuilder interface. Used here to either calculate an objects per-user FLS, OR to return it from Cache. The return datastructure for this is Map<String, Map<FLSType,Boolean>> and represents: FieldName -> FLStype -> True/False Signature public Object doLoad(String objType) Parameters objType Type: String String object name used as the cache key Returns Object edit(obj) convenience api for determining if the running user can edit / update the specified object Signature public static Boolean edit(SObject obj) Parameters obj Type: SObject object type to check edit permissions on Returns Boolean Example System.debug(CanTheUser.edit(new Account())); edit(objs) convenience api for determining if the running user can edit / update the specified objects Signature public static Boolean edit(List<SObject> objs) Parameters obj object type to check edit permissions on Returns Boolean edit(objName) convenience api for determining if the running user can edit the specified object Signature public static Boolean edit(String objName) Parameters String Object type to check edit permissions on Returns Boolean Example System.debug(CanTheUser.edit('Account')); flsAccessible(obj, field) public method to determine if a given field on a given object is Accessible(readable) Signature public static Boolean flsAccessible(String obj, String field) Parameters obj Type: String the object in question, in string form field Type: String the field in question in SObjectField form Returns Boolean Example System.debug(CanTheUser.flsAccessible('Account', 'Name')); flsUpdatable(obj, field) public method to determine if a given field on a given object is Updatable. Signature public static Boolean flsUpdatable(String obj, String field) Parameters obj Type: String the string version of an object name field Type: String the field to check Returns Boolean Example System.debug(CanTheUser.flsUpdatable('Account', 'Name')); read(obj) convenience api for determining if the running user can read / access the specified object Signature public static Boolean read(SObject obj) Parameters obj Type: SObject object type to check read permissions on Returns Boolean Example System.debug(CanTheUser.read(new Account())); read(objs) convenience api for determining if the running user can read / access the specified objects Signature public static Boolean read(List<SObject> objs) Parameters obj object type to check read permissions on Returns Boolean read(objName) convenience api for determining if the running user can read the specified object Signature public static Boolean read(String objName) Parameters String Object type to check read permissions on Returns Boolean Example System.debug(CanTheUser.read('Account')); ups(obj) convenience api for determining if the running user can upsert(insert and update) the specified objects Signature public static Boolean ups(SObject obj) Parameters obj Type: SObject object type to check edit permissions on Returns Boolean Example System.debug(CanTheUser.ups(new Account())); ups(objs) convenience api for determining if the running user can edit / update the specified objects Signature public static Boolean ups(List<SObject> objs) Parameters obj object type to check upsert permissions on Returns Boolean ups(objName) convenience api for determining if the running user can upsert the specified object Signature public static Boolean ups(String objName) Parameters String Object type to check upsert permissions on Returns Boolean Example System.debug(CanTheUser.ups('Account'));"
	},
	{
		title: 'Safely',
		fileName: 'Safely.html',
		text: 'Safely Class wraps DML Calls in FLS / Crud checks. Library is baseed on a fluent api system. All calls are constructed, then chained with options. For instances. new Safely().allOrNothing().doInsert(List<sObject>);   Notable chainable methods include: - allOrNothing() - this enforces the AllOrNothing DML flag. All DML is eventually executed via Database.* methods which accept an allOrNothing parameter requiring all of the records to succeed or fail. - throwIfRemovedFields() - this method, if called, will result in an exception being thrown if any record being modified has fields removed by the security decision. Signature public with sharing class Safely Example new Safely().allOrNothing().doInsert(List<sObject>); Safely Properties Name Signature Annotations allOrNothing private Boolean allOrNothing @testVisible throwIfRemovedFields private Boolean throwIfRemovedFields @testVisible Safely Methods allOrNothing() doDelete(records) doDelete(record) doDML(accessType, records) doInsert(records) doInsert(record) doQuery(query) doUpdate(records) doUpdate(record) doUpsert(records) doUpsert(record) guardAgainstRemovedFields(accessType, records) throwIfRemovedFields() allOrNothing() Signature public Safely allOrNothing() doDelete(records) Signature public List<Database.DeleteResult> doDelete(List<SObject> records) doDelete(record) Signature public List<Database.DeleteResult> doDelete(SObject record) doDML(accessType, records) Signature private List<Database.SaveResult> doDML(\t\tSystem.AccessType accessType,\t\tList<SObject> records\t) doInsert(records) Signature public List<Database.SaveResult> doInsert(List<SObject> records) doInsert(record) Signature public List<Database.SaveResult> doInsert(SObject record) doQuery(query) Signature public List<SObject> doQuery(String query) doUpdate(records) Signature public List<Database.SaveResult> doUpdate(List<SObject> records) doUpdate(record) Signature public List<Database.SaveResult> doUpdate(SObject record) doUpsert(records) Signature public List<Database.UpsertResult> doUpsert(List<SObject> records) doUpsert(record) Signature public List<Database.UpsertResult> doUpsert(Sobject record) guardAgainstRemovedFields(accessType, records) Signature private SObjectAccessDecision guardAgainstRemovedFields(\t\tSystem.AccessType accessType,\t\tList<SObject> records\t) throwIfRemovedFields() Signature public Safely throwIfRemovedFields() Safely.RemovedFieldsException Signature public class RemovedFieldsException extends Exception'
	},
	{
		title: 'LogTriggerHandler',
		fileName: 'LogTriggerHandler.html',
		text: 'LogTriggerHandler Signature public with sharing class LogTriggerHandler LogTriggerHandler Properties Name Signature logs private List<Log__e> logs shouldThrow private Boolean shouldThrow LogTriggerHandler Constructors LogTriggerHandler(logs, shouldThrow) LogTriggerHandler(logs) LogTriggerHandler(logs, shouldThrow) Signature public LogTriggerHandler(List<Log__e> logs, Boolean shouldThrow) LogTriggerHandler(logs) Signature public LogTriggerHandler(List<Log__e> logs) LogTriggerHandler Methods afterInsert() afterInsert() Signature public void afterInsert()'
	},
	{
		title: 'InvokeMetadataDrivenTriggerFramework',
		fileName: 'InvokeMetadataDrivenTriggerFramework.html',
		text: 'InvokeMetadataDrivenTriggerFramework Signature public with sharing class InvokeMetadataDrivenTriggerFramework InvokeMetadataDrivenTriggerFramework Methods invokeMetadataTriggerFramework(inputParams) invokeMetadataTriggerFramework(inputParams) Signature public static void invokeMetadataTriggerFramework(List<inputs> inputParams) InvokeMetadataDrivenTriggerFramework.Inputs Signature public class Inputs InvokeMetadataDrivenTriggerFramework.Inputs Properties Name Signature context public TriggerContext.ValidTriggerContexts context triggerNew public List<SObject> triggerNew triggerOld public List<SObject> triggerOld'
	},
	{
		title: 'MetadataTriggerFramework',
		fileName: 'MetadataTriggerFramework.html',
		text: "MetadataTriggerFramework Signature public with sharing class MetadataTriggerFramework extends TriggerFramework MetadataTriggerFramework Properties Name Signature Annotations activeHandler private TriggerFramework activeHandler @testVisible mts private MetadataTriggerQueryService mts @testVisible triggerNew protected List<sObject> triggerNew triggerOld protected List<sObject> triggerOld triggers private List<Metadata_Driven_Trigger__mdt> triggers @testVisible MetadataTriggerFramework Constructors MetadataTriggerFramework() Constructor used by live triggers. MetadataTriggerFramework(triggerNew, triggerOld, context) MetadataTriggerFramework(mts) MetadataTriggerFramework() Constructor used by live triggers. Signature public MetadataTriggerFramework() MetadataTriggerFramework(triggerNew, triggerOld, context) Signature public MetadataTriggerFramework(\t\tList<sObject> triggerNew,\t\tList<sObject> triggerOld,\t\tTriggerContext.ValidTriggerContexts context\t) MetadataTriggerFramework(mts) Signature public MetadataTriggerFramework(MetadataTriggerQueryService mts) MetadataTriggerFramework Methods dispatch(activeHandler) This loop is responsible for instantiating the trigger handler classes identified by the query above, and then calling the proper context methods. run() Overrides the standard Run() method, which allows this metadata based trigger handler can be an incremental update / sit beside other trigger handlers classes that are directly invoked by a trigger dispatch(activeHandler) This loop is responsible for instantiating the trigger handler classes identified by the query above, and then calling the proper context methods. Signature private void dispatch(TriggerFramework activeHandler) run() Overrides the standard Run() method, which allows this metadata based trigger handler can be an incremental update / sit beside other trigger handlers classes that are directly invoked by a trigger Signature @SuppressWarnings('PMD.ApexCRUDViolation') override public void run() MetadataTriggerFramework.MetadataTriggerFrameworkException Signature public class MetadataTriggerFrameworkException extends Exception"
	},
	{
		title: 'MetadataTriggerQueryService',
		fileName: 'MetadataTriggerQueryService.html',
		text: "MetadataTriggerQueryService Signature public with sharing class MetadataTriggerQueryService MetadataTriggerQueryService Properties Name Signature objType private String objType MetadataTriggerQueryService Constructors MetadataTriggerQueryService(objectTypeName) MetadataTriggerQueryService(objectTypeName) Signature public MetadataTriggerQueryService(String objectTypeName) MetadataTriggerQueryService Methods getMetadataTriggers() This query finds an ordered list trigger handler classes to execute. It ignores any classes that are marked as disabled. Note: It will exclude any triggerHandler metadata records for which the user's email address is found in a related disabled_for__mdt record. Admins and Developers can selectively disable trigger handlers for all or selected individuals *without* deploying. getSObjectType(triggerNew, triggerOld) This determines the active sObject type by describing the first record in the trigger New / Old list getMetadataTriggers() This query finds an ordered list trigger handler classes to execute. It ignores any classes that are marked as disabled. Note: It will exclude any triggerHandler metadata records for which the user's email address is found in a related disabled_for__mdt record. Admins and Developers can selectively disable trigger handlers for all or selected individuals *without* deploying. Signature @suppressWarnings('PMD.ApexCRUDViolation') public List<Metadata_Driven_Trigger__mdt> getMetadataTriggers() Returns List<Metadata_Driven_Trigger__mdt> getSObjectType(triggerNew, triggerOld) This determines the active sObject type by describing the first record in the trigger New / Old list Signature public static String getSObjectType(\t\tList<sObject> triggerNew,\t\tList<sObject> triggerOld\t) Parameters triggerNew Type: \t\tList<sObject> Trigger.new description triggerOld Trigger.old description Returns String  SObjectType(name?)"
	},
	{
		title: 'TriggerContext',
		fileName: 'TriggerContext.html',
		text: 'TriggerContext Signature public with sharing class TriggerContext TriggerContext Properties Name Signature context public validTriggerContexts context isTriggerBeingTested public Boolean isTriggerBeingTested Enums Name Signature Values Description ValidTriggerContexts public enum ValidTriggerContexts BEFORE_INSERT, BEFORE_UPDATE, BEFORE_DELETE, AFTER_INSERT, AFTER_UPDATE, AFTER_DELETE, AFTER_UNDELETE possible trigger contexts TriggerContext Methods isInvalidExecutionContext() make sure this trigger should continue to run setContextDuringNormalExecution() This block is executed during normal operation. setManuallyOverriddenContext(overriddenContext) setTriggerContext() internal method to forcibly set the trigger context setTriggerContext(overriddenContext, overrideForTesting) Internal method for manually setting the trigger context isInvalidExecutionContext() make sure this trigger should continue to run Signature @testVisible public Boolean isInvalidExecutionContext() Returns Boolean Exceptions TriggerHandlerException thrown when executing outside of a trigger setContextDuringNormalExecution() This block is executed during normal operation. Signature private void setContextDuringNormalExecution() setManuallyOverriddenContext(overriddenContext) Signature private void setManuallyOverriddenContext(String overriddenContext) setTriggerContext() internal method to forcibly set the trigger context Signature @testVisible private void setTriggerContext() setTriggerContext(overriddenContext, overrideForTesting) Internal method for manually setting the trigger context Signature private void setTriggerContext(\t\tString overriddenContext,\t\tBoolean overrideForTesting\t) Parameters ctx      The current trigger Context testMode Is the trigger running in a test context?'
	},
	{
		title: 'TriggerFramework',
		fileName: 'TriggerFramework.html',
		text: "TriggerFramework An opinionated trigger handler framework. Signature public virtual class TriggerFramework TriggerFramework Properties Name Signature Annotations bypassedHandlers public static Set<String> bypassedHandlers loopCountMap private static Map<String, TriggerFramework.TriggerFrameworkLoopCount> loopCountMap triggerContext protected TriggerContext triggerContext @testVisible TriggerFramework Constructors TriggerFramework() Constructs a trigger handler object and ensures the context is set TriggerFramework() Constructs a trigger handler object and ensures the context is set Signature public TriggerFramework() TriggerFramework Methods addToLoopCount() private instance methods afterDelete() Virtual method for the implementing class to override afterInsert() Virtual method for the implementing class to override afterUndelete() Virtual method for the implementing class to override afterUpdate() Virtual method for the implementing class to override beforeDelete() Virtual method for the implementing class to override beforeInsert() context methods beforeUpdate() Virtual method for the implementing class to override bypass(handlerName) Allows developers to conditionally bypass(disable) other triggers that *also* implement this TriggerFramework clearAllBypasses() removes all classes from the bypass list clearBypass(handlerName) Removes a given trigger handler class name from the list of bypassed trigger handlers. clearMaxLoopCount() Allows developers to turn off the max loop count dispatchHandlerMethod(context) Guard statements against invalid execution context and a bypassed handlerName exceeded() Determines if this we're about to exceed the loop count. getCount() Returns the current loop count. getHandlerName() Returns the string version of the handler class being invoked getMax() Returns the max loop count. increment() Increment the internal counter returning the results of this.exceeded(). isBypassed(handlerName) Allows developers to check whether a given trigger handler class is currently bypassed. run() This is main brokering method that is called by the trigger. It's responsible for determining the proper context, and calling the correct method setMax(max) Sets the max loop size setMaxLoopCount(max) Allows developers to prevent trigger loops, or allow a limited number of them by setting the maximum number of times this trigger is called. standardValidation() TriggerFrameworkLoopCount(max) Sets loop count based on the param. addToLoopCount() private instance methods Signature @testVisible protected void addToLoopCount() afterDelete() Virtual method for the implementing class to override Signature @testVisible protected virtual void afterDelete() afterInsert() Virtual method for the implementing class to override Signature @testVisible protected virtual void afterInsert() afterUndelete() Virtual method for the implementing class to override Signature @testVisible protected virtual void afterUndelete() afterUpdate() Virtual method for the implementing class to override Signature @testVisible protected virtual void afterUpdate() beforeDelete() Virtual method for the implementing class to override Signature @testVisible protected virtual void beforeDelete() beforeInsert() context methods Signature @testVisible protected virtual void beforeInsert() beforeUpdate() Virtual method for the implementing class to override Signature @testVisible protected virtual void beforeUpdate() bypass(handlerName) Allows developers to conditionally bypass(disable) other triggers that *also* implement this TriggerFramework Signature public static void bypass(String handlerName) Parameters handlerName Type: String Class name(String) of the trigger handler to bypass Example TriggerFramework.bypass('AccountTriggerFramework'); clearAllBypasses() removes all classes from the bypass list Signature public static void clearAllBypasses() Example TriggerFramework.clearAllBypasses(); clearBypass(handlerName) Removes a given trigger handler class name from the list of bypassed trigger handlers. Signature public static void clearBypass(String handlerName) Parameters handlerName Type: String Handler class name to remove from the bypass list Example TriggerFramework.clearBypass('AccountTriggerFramework'); clearMaxLoopCount() Allows developers to turn off the max loop count Signature public void clearMaxLoopCount() Example In the context of a TriggerFramework class, this.clearMaxLoopCount(); dispatchHandlerMethod(context) Guard statements against invalid execution context and a bypassed handlerName Signature private void dispatchHandlerMethod(\t\tTriggerContext.ValidTriggerContexts context\t) exceeded() Determines if this we're about to exceed the loop count. Signature public Boolean exceeded() Returns Boolean  true if less than 0 or more than max. getCount() Returns the current loop count. Signature public Integer getCount() Returns Integer  current loop count. getHandlerName() Returns the string version of the handler class being invoked Signature @testVisible protected String getHandlerName() Returns String  Name of the Handler getMax() Returns the max loop count. Signature public Integer getMax() Returns Integer  max loop count. increment() Increment the internal counter returning the results of this.exceeded(). Signature public Boolean increment() Returns Boolean  true if count will exceed max count or is less than 0. isBypassed(handlerName) Allows developers to check whether a given trigger handler class is currently bypassed. Signature public static Boolean isBypassed(String handlerName) Parameters handlerName Type: String The name of the trigger handler class to check for Returns Boolean Example TriggerFramework.isBypassed('AccountTriggerFramework'); run() This is main brokering method that is called by the trigger. It's responsible for determining the proper context, and calling the correct method Signature public virtual void run() Example AccountTriggerFramework.run(); setMax(max) Sets the max loop size Signature public void setMax(Integer max) Parameters max Type: Integer The integer to set max to. setMaxLoopCount(max) Allows developers to prevent trigger loops, or allow a limited number of them by setting the maximum number of times this trigger is called. Signature public void setMaxLoopCount(Integer max) Parameters max Type: Integer A valid number(generally 1) of times you'd like to allow the trigger to run. Example In the context of a TriggerFramework class, this.setMaxLoopCount(5); standardValidation() Signature protected void standardValidation() TriggerFrameworkLoopCount(max) Sets loop count based on the param. Signature public TriggerFrameworkLoopCount(Integer max) Parameters max Type: Integer Maximum number of loops to allow. TriggerFramework.TriggerFrameworkException Signature public class TriggerFrameworkException extends Exception TriggerFramework.TriggerFrameworkLoopCount Inner class for managing the loop count per handler Signature public class TriggerFrameworkLoopCount TriggerFramework.TriggerFrameworkLoopCount Properties Name Signature count public Integer count max public Integer max TriggerFramework.TriggerFrameworkLoopCount Constructors TriggerFrameworkLoopCount() Loop counter method with default of 5. TriggerFrameworkLoopCount() Loop counter method with default of 5. Signature public TriggerFrameworkLoopCount()"
	},
	{
		title: 'MetadataTriggerFrameworkTests',
		fileName: 'MetadataTriggerFrameworkTests.html',
		text: 'MetadataTriggerFrameworkTests Signature @isTest private class MetadataTriggerFrameworkTests MetadataTriggerFrameworkTests Methods exerciseTriggerHandlerPositive(context) testExecutesAfterDeletePositive() testExecutesAfterInsertPositive() testExecutesAfterUndeletePositive() testExecutesAfterUpdatePositive() testExecutesBeforeDeletePositive() testExecutesBeforeInsertPositive() testExecutesBeforeUpdatePositive() testMetadataTriggerFrameworkNoOppWithoutRecordsPositive() exerciseTriggerHandlerPositive(context) Signature private static void exerciseTriggerHandlerPositive(String context) testExecutesAfterDeletePositive() Signature @isTest static void testExecutesAfterDeletePositive() testExecutesAfterInsertPositive() Signature @isTest static void testExecutesAfterInsertPositive() testExecutesAfterUndeletePositive() Signature @isTest static void testExecutesAfterUndeletePositive() testExecutesAfterUpdatePositive() Signature @isTest static void testExecutesAfterUpdatePositive() testExecutesBeforeDeletePositive() Signature @isTest static void testExecutesBeforeDeletePositive() testExecutesBeforeInsertPositive() Signature @isTest static void testExecutesBeforeInsertPositive() testExecutesBeforeUpdatePositive() Signature @isTest static void testExecutesBeforeUpdatePositive() testMetadataTriggerFrameworkNoOppWithoutRecordsPositive() Signature @isTest static void testMetadataTriggerFrameworkNoOppWithoutRecordsPositive()'
	},
	{
		title: 'MetadataTriggerQueryServiceTests',
		fileName: 'MetadataTriggerQueryServiceTests.html',
		text: 'MetadataTriggerQueryServiceTests Signature @isTest private class MetadataTriggerQueryServiceTests MetadataTriggerQueryServiceTests Methods testGetMetadataTriggers() testGetSObjectTypeNegative() testGetSObjectTypePositiveFromTriggerNew() testGetSObjectTypePositiveFromTriggerOld() testGetMetadataTriggers() Signature @isTest static void testGetMetadataTriggers() testGetSObjectTypeNegative() Signature @isTest static void testGetSObjectTypeNegative() testGetSObjectTypePositiveFromTriggerNew() Signature @isTest static void testGetSObjectTypePositiveFromTriggerNew() testGetSObjectTypePositiveFromTriggerOld() Signature @isTest static void testGetSObjectTypePositiveFromTriggerOld()'
	},
	{
		title: 'SampleHandler',
		fileName: 'SampleHandler.html',
		text: 'SampleHandler This class is a sample trigger handler for use while testing MetadataTriggerHandler . Because custom metadata cannot be inserted, and because the MetadataTriggerHandler  instantiates handler classes from custom metadata records, even when we stub/mock the metadata record retrieval we still need an actual class that it can instantiate. Note, this class is annotated with isTest  to prevent its use outside of tests, not because it contains tests. Signature @isTest public class SampleHandler extends TriggerFramework SampleHandler Methods afterDelete() afterInsert() afterUndelete() afterUpdate() beforeDelete() beforeInsert() beforeUpdate() afterDelete() Signature public override void afterDelete() afterInsert() Signature public override void afterInsert() afterUndelete() Signature public override void afterUndelete() afterUpdate() Signature public override void afterUpdate() beforeDelete() Signature public override void beforeDelete() beforeInsert() Signature public override void beforeInsert() beforeUpdate() Signature public override void beforeUpdate()'
	},
	{
		title: 'TriggerFrameworkTests',
		fileName: 'TriggerFrameworkTests.html',
		text: 'TriggerFrameworkTests Signature @testVisible private class TriggerFrameworkTests TriggerFrameworkTests Properties Name Signature handler private static TriggerFrameworkTests.TestHandler handler lastMethodCalled private static String lastMethodCalled TRIGGER_CONTEXT_ERROR private static final String TRIGGER_CONTEXT_ERROR TriggerFrameworkTests Methods afterDeleteMode() afterInsertMode() afterUndeleteMode() afterUpdateMode() beforeDeleteMode() beforeInsertMode() beforeUpdateMode() resetTest() testing utilities testAfterDelete() testAfterInsert() testAfterUndelete() testAfterUpdate() testBeforeDelete() testBeforeInsert() unit tests testBeforeUpdate() testBypassAPI() testGetHandlerName() testLoopCount() testLoopCountClass() testNonTriggerContext() testVirtualMethods() afterDeleteMode() Signature private static void afterDeleteMode() afterInsertMode() Signature private static void afterInsertMode() afterUndeleteMode() Signature private static void afterUndeleteMode() afterUpdateMode() Signature private static void afterUpdateMode() beforeDeleteMode() Signature private static void beforeDeleteMode() beforeInsertMode() Signature private static void beforeInsertMode() beforeUpdateMode() Signature private static void beforeUpdateMode() resetTest() testing utilities Signature private static void resetTest() testAfterDelete() Signature @isTest static void testAfterDelete() testAfterInsert() Signature @isTest static void testAfterInsert() testAfterUndelete() Signature @isTest static void testAfterUndelete() testAfterUpdate() Signature @isTest static void testAfterUpdate() testBeforeDelete() Signature @isTest static void testBeforeDelete() testBeforeInsert() unit tests Signature @isTest static void testBeforeInsert() testBeforeUpdate() Signature @isTest static void testBeforeUpdate() testBypassAPI() Signature @isTest static void testBypassAPI() testGetHandlerName() Signature @isTest static void testGetHandlerName() testLoopCount() Signature @isTest static void testLoopCount() testLoopCountClass() Signature @isTest static void testLoopCountClass() testNonTriggerContext() Signature @isTest static void testNonTriggerContext() testVirtualMethods() Signature @isTest static void testVirtualMethods() TriggerFrameworkTests.TestHandler Signature @testVisible private class TestHandler extends TriggerFramework TriggerFrameworkTests.TestHandler Methods afterDelete() afterInsert() afterUndelete() afterUpdate() beforeDelete() beforeInsert() beforeUpdate() afterDelete() Signature public override void afterDelete() afterInsert() Signature public override void afterInsert() afterUndelete() Signature public override void afterUndelete() afterUpdate() Signature public override void afterUpdate() beforeDelete() Signature public override void beforeDelete() beforeInsert() Signature public override void beforeInsert() beforeUpdate() Signature public override void beforeUpdate()'
	},
	{
		title: 'MethodSignature',
		fileName: 'MethodSignature.html',
		text: "MethodSignature Class models a callable apex method's 'signature' or combination of Name, Parameter types and Parameter values. This is separate from a MockedMethod, because it can be constructed at runtime for comparison against established MockedMethods. Signature public with sharing class MethodSignature MethodSignature Properties Name Signature Annotations methodName private String methodName @testVisible methodParameterTypes private List<Type> methodParameterTypes @testVisible MethodSignature Constructors MethodSignature(methodName, paramTypes) Constructor requiring a method name and list of parameters. This method cannot be constructed without these. MethodSignature(methodName, paramTypes) Constructor requiring a method name and list of parameters. This method cannot be constructed without these. Signature public MethodSignature(String methodName, List<Type> paramTypes) Parameters methodName Type: String paramTypes Type: List<Type> MethodSignature Methods buildMockedMethod() Creates the MockedMethod matching this method signature. finalizeSignature() Called at the end of building a method signature. getMethodName() verifyMethodNamesMatch(originalMethodName, comparitorMethodName) Returns true if the current MethodSignature's methodName is a case insensitive match to the comparison's methodName verifySignatureMatch(otherSignature) This is used to compare the signature of a MockedMethod, against another instance. Used at runtime to compare an actually requested method call against pre-defined mocks. withParameterTypes(parameters) This variant handles the situation where a mocked method was called without parameters. withParameterTypes(paramater) This variant handles a single parameter, brokers to omnibus method. withParameterTypes(parameter, parameter2) Two parameter variant. Brokers to omnibus method. withParameterTypes(parameter, parameter2, parameter3) Three parameter variant. Brokers to omnibus method. withParameterTypes(parameter, parameter2, parameter3, parameter4) Four parameter variant. Brokers to omnibus method. buildMockedMethod() Creates the MockedMethod matching this method signature. Signature public List<MockedMethod> buildMockedMethod() Returns List<MockedMethod> finalizeSignature() Called at the end of building a method signature. Signature public Stub.Builder finalizeSignature() Returns Stub.Builder getMethodName() Signature public String getMethodName() verifyMethodNamesMatch(originalMethodName, comparitorMethodName) Returns true if the current MethodSignature's methodName is a case insensitive match to the comparison's methodName Signature private Boolean verifyMethodNamesMatch(\t\tString originalMethodName,\t\tString comparitorMethodName\t) Parameters originalMethodName Type: \t\tString comparitorMethodName Returns Boolean verifySignatureMatch(otherSignature) This is used to compare the signature of a MockedMethod, against another instance. Used at runtime to compare an actually requested method call against pre-defined mocks. Signature public Boolean verifySignatureMatch(MethodSignature otherSignature) Parameters otherInstance Returns Boolean withParameterTypes(parameters) This variant handles the situation where a mocked method was called without parameters. Signature public MockedMethod.Builder withParameterTypes(\t\t\tList<System.Type> parameters\t\t) Returns MockedMethod.Builder withParameterTypes(paramater) This variant handles a single parameter, brokers to omnibus method. Signature public MockedMethod.Builder withParameterTypes(System.Type paramater) Parameters parameter Returns MockedMethod.Builder withParameterTypes(parameter, parameter2) Two parameter variant. Brokers to omnibus method. Signature public MockedMethod.Builder withParameterTypes(\t\t\tSystem.Type parameter,\t\t\tSystem.Type parameter2\t\t) Parameters parameter Type: \t\t\tSystem.Type parameter2 Returns MockedMethod.Builder withParameterTypes(parameter, parameter2, parameter3) Three parameter variant. Brokers to omnibus method. Signature public MockedMethod.Builder withParameterTypes(\t\t\tSystem.Type parameter,\t\t\tSystem.Type parameter2,\t\t\tSystem.Type parameter3\t\t) Parameters parameter Type: \t\t\tSystem.Type parameter2 parameter3 Returns MockedMethod.Builder withParameterTypes(parameter, parameter2, parameter3, parameter4) Four parameter variant. Brokers to omnibus method. Signature public MockedMethod.Builder withParameterTypes(\t\t\tSystem.Type parameter,\t\t\tSystem.Type parameter2,\t\t\tSystem.Type parameter3,\t\t\tSystem.Type parameter4\t\t) Parameters parameter Type: \t\t\tSystem.Type parameter2 parameter3 parameter4 Returns MockedMethod.Builder MethodSignature.Builder While a MethodSignature object can be created directly the more common usecase is to use this Builder class to construct the MethodSignature object in a Fluent api style. Signature public class Builder MethodSignature.Builder Properties Name Signature Annotations methodName private String methodName @testVisible parameterTypes public List<Type> parameterTypes @testVisible stubBuilder private Stub.Builder stubBuilder MethodSignature.Builder Constructors Builder(builder, methodName, paramTypes) Constructor. Builder(builder, methodName, paramTypes) Constructor. Signature public Builder(\t\t\tStub.Builder builder,\t\t\tString methodName,\t\t\tList<System.Type> paramTypes\t\t) Parameters builder Type: \t\t\tStub.Builder A Stub.Builder object methodName String referencing the name of the method minus things like() paramTypes A list of System.Types that define the order and type of parameters for the method."
	},
	{
		title: 'MockedMethod',
		fileName: 'MockedMethod.html',
		text: "MockedMethod Represents a method call that is mocked as part of a Stub object. This class is marked @isTest, as the object and it's methods are not useful outside of a Test context. This file contains not only the MockedMethod class, but an inner Builder class. It is expected most developers will utilize the Builder class to construct instances of MockedMethod. Signature public with sharing class MockedMethod MockedMethod Properties Name Signature Annotations Description countOfMethodInvocations private Integer countOfMethodInvocations customException private Exception customException exceptionMessage private static String exceptionMessage @testVisible expectedParameters private List<Object> expectedParameters methodSignature private MethodSignature methodSignature @testVisible Every MockedMethod has a methodSignature defining it's 'signature' or combination of name, parameter names and parameter types. returnValue private Object returnValue sObjectIds private List<Id> sObjectIds throwException private Boolean throwException MockedMethod Constructors MockedMethod(methodSignature) Constructor requiring a method signature. This is used to prevent constructing MockedMethods without a signature. MockedMethod(methodSignature) Constructor requiring a method signature. This is used to prevent constructing MockedMethods without a signature. Signature public MockedMethod(MethodSignature methodSignature) Parameters methodSignature Type: MethodSignature We need this to define the shape of the method being mocked. MockedMethod Methods assertMockedMethodWasCalled() If this MockedMethod has not been called cause a failing assertion. createMockedMethod(signature) Responsible for returning a fully formed MockedMethod instance. doMethodSignaturesAndParametersMatch(methodSignature, runtimeParameters) determines if the current method call matches on both a method signature level and against specified input parameters. doRuntimeParametersMatch(compareTo) Determines if the method, as brokered by the stub object is being called with an expected set of parameters. Note: I thought I could replace this with return this.methodParamsAtExecutionTime.equals(compareTo);  but this doesn't work, and to be honest, I'm still investigating why. handleCall() This method is invoked by it's parent stub object, and is responsible for returning the mocked value. returning(returnValue) Sets this MockedMethod's return value. This is the value that will be returned by this mocked method when the stub calls a method that has an identical name, signature and input paramter list. returning(incomingIds) Use this variant of returning when you want the mocked method to return a list of sObjects(generic) with a specific set of IDs returning(returnValue) This variant allows developers to specify the object that will be returned when this mocked method is executed by its parent stub. returning() This variant allows developers to specify a void return. returningObjectsWithIds(ids) This variant allows developers to specify a list of IDs to be assigned to the returning sObject List throwingException() Use this method when you need the mocked method to throw an exception. Incredibly useful for testing exception handling! Note: This variant results in a generic StubException being thrown. throwingException(customException) Use this variant to have this mocked method return a developer-specified exception object. Useful for testing exception handling with specific exception types. throwingException() This variant allows developers to throw an internally generated Stub.StubException object when the method is executed. throwingException(customException) Use this variant to have this mocked method return a developer-specified exception object. Useful for testing exception handling with specific exception types. Note: This only works for custom exceptions. Note: Developers construct your exception  like this: <CustomExceptioType> customException =   new <CustomExceptionType>('message'); withParameterValues(args) Allows developers to define expected input parameters at execution time. This enables developers to mock the same method call N number of times, with different input parameters. withParameterValues(parameter) internal method used to set the parameter values of this MockedMethod instance. withParameterValues(parameter, parameter2) convenience methodfor setting two params withParameterValues(parameter, parameter2, parameter3) convenience methodfor setting three params withParameterValues(parameter, parameter2, parameter3, parameter4) convenience methodfor setting four parameters assertMockedMethodWasCalled() If this MockedMethod has not been called cause a failing assertion. Signature @SuppressWarnings('pmd.ApexUnitTestMethodShouldHaveIsTestAnnotation') public void assertMockedMethodWasCalled() createMockedMethod(signature) Responsible for returning a fully formed MockedMethod instance. Signature public MockedMethod createMockedMethod(MethodSignature signature) Parameters signature Type: MethodSignature Returns MockedMethod doMethodSignaturesAndParametersMatch(methodSignature, runtimeParameters) determines if the current method call matches on both a method signature level and against specified input parameters. Signature public Boolean doMethodSignaturesAndParametersMatch(\t\tMethodSignature methodSignature,\t\tList<Object> runtimeParameters\t) Parameters methodSignature Type: \t\tMethodSignature A method signature to match against. runtimeParameters a List of objects representing the actual values - at runtime - of the method call. Returns Boolean doRuntimeParametersMatch(compareTo) Determines if the method, as brokered by the stub object is being called with an expected set of parameters. Note: I thought I could replace this with return this.methodParamsAtExecutionTime.equals(compareTo);  but this doesn't work, and to be honest, I'm still investigating why. Signature private Boolean doRuntimeParametersMatch(List<Object> compareTo) Parameters compareTo Type: List<Object> Returns Boolean handleCall() This method is invoked by it's parent stub object, and is responsible for returning the mocked value. Signature public Object handleCall() Returns Object returning(returnValue) Sets this MockedMethod's return value. This is the value that will be returned by this mocked method when the stub calls a method that has an identical name, signature and input paramter list. Signature public MockedMethod returning(Object returnValue) Parameters returnValue Type: Object This is the object you want returned. Returns MockedMethod returning(incomingIds) Use this variant of returning when you want the mocked method to return a list of sObjects(generic) with a specific set of IDs Signature public MockedMethod returning(List<Id> incomingIds) Parameters incomingIds Type: List<Id> A list of ID's. Note, they don't have to be ids of the same sObject type. Order is preserved. Returns MockedMethod returning(returnValue) This variant allows developers to specify the object that will be returned when this mocked method is executed by its parent stub. Signature public Stub.Builder returning(Object returnValue) Parameters returnValue Type: Object Returns Stub.Builder returning() This variant allows developers to specify a void return. Signature public Stub.Builder returning() Returns Stub.Builder returningObjectsWithIds(ids) This variant allows developers to specify a list of IDs to be assigned to the returning sObject List Signature public Stub.Builder returningObjectsWithIds(List<Id> ids) Parameters ids Type: List<Id> The list of Ids to assign. Returns MockedMethod.Builder throwingException() Use this method when you need the mocked method to throw an exception. Incredibly useful for testing exception handling! Note: This variant results in a generic StubException being thrown. Signature public MockedMethod throwingException() Returns MockedMethod throwingException(customException) Use this variant to have this mocked method return a developer-specified exception object. Useful for testing exception handling with specific exception types. Signature public MockedMethod throwingException(Exception customException) Parameters customException Type: Exception Returns MockedMethod throwingException() This variant allows developers to throw an internally generated Stub.StubException object when the method is executed. Signature public Stub.Builder throwingException() Returns Stub.Builder throwingException(customException) Use this variant to have this mocked method return a developer-specified exception object. Useful for testing exception handling with specific exception types. Note: This only works for custom exceptions. Note: Developers construct your exception  like this: <CustomExceptioType> customException =   new <CustomExceptionType>('message'); Signature public Stub.Builder throwingException(Exception customException) Parameters customException Type: Exception Returns MockedMethod withParameterValues(args) Allows developers to define expected input parameters at execution time. This enables developers to mock the same method call N number of times, with different input parameters. Signature public MockedMethod withParameterValues(List<Object> args) Parameters args Type: List<Object> A list of Objects that you want to this MockedMethod to to respond to. These objects must exactly match what your code invokes in order for your stub to return the specified mock output. Returns MockedMethod withParameterValues(parameter) internal method used to set the parameter values of this MockedMethod instance. Signature public MockedMethod.Builder withParameterValues(Object parameter) Parameters parameters list of System.Type Returns MockedMethod withParameterValues(parameter, parameter2) convenience methodfor setting two params Signature public MockedMethod.Builder withParameterValues(\t\t\tObject parameter,\t\t\tObject parameter2\t\t) Parameters parameter Type: \t\t\tObject System.Type parameter2 System.Type Returns this withParameterValues(parameter, parameter2, parameter3) convenience methodfor setting three params Signature public MockedMethod.Builder withParameterValues(\t\t\tObject parameter,\t\t\tObject parameter2,\t\t\tObject parameter3\t\t) Parameters parameter Type: \t\t\tObject System.Type parameter2 System.Type parameter3 System.Type Returns return description withParameterValues(parameter, parameter2, parameter3, parameter4) convenience methodfor setting four parameters Signature public MockedMethod.Builder withParameterValues(\t\t\tObject parameter,\t\t\tObject parameter2,\t\t\tObject parameter3,\t\t\tObject parameter4\t\t) Parameters parameter Type: \t\t\tObject parameter description parameter2 parameter2 description parameter3 parameter3 description parameter4 parameter4 description Returns this MockedMethod.Builder class provides a 'builder' or fluent interface for constructing MockedMethod objects. While the end-developer can create MockedMethod objects directly, the point of this class is to provide an intuitive and easy-to-use/comprehend interface for building nuanced MockedMethod Objects. Signature public class Builder MockedMethod.Builder Properties Name Signature customException private Exception customException methodSignatureBuilder private MethodSignature.Builder methodSignatureBuilder returnSObjectIds private List<Id> returnSObjectIds returnValue private Object returnValue runtimeParameters private List<Object> runtimeParameters throwException private Boolean throwException MockedMethod.Builder Constructors Builder(methodSignatureBuilder, args) Constructor requiring a methodSignatureBuilder object and a list of runtime arguments Builder(methodSignatureBuilder, args) Constructor requiring a methodSignatureBuilder object and a list of runtime arguments Signature public Builder(\t\t\tMethodSignature.Builder methodSignatureBuilder,\t\t\tList<System.Type> args\t\t) Parameters methodSignatureBuilder Type: \t\t\tMethodSignature.Builder args"
	},
	{
		title: 'Stub',
		fileName: 'Stub.html',
		text: "Stub This class helps you construct and manage StubProvider conforming objects for use in Unit Tests. It, along with its companion classes:   * MockedMethod   * MethodSignature and their builder-pattern inner classes are designed to work together with a fluent API style. Signature public with sharing class Stub implements System.StubProvider Example StubObject fooStub = new StubObject.Builder('foo.class') .mockingMethodCall('someMethodName', List<Object> Params) .withParameterTypes() .returning() || .throwingException() || .throwingException(ExceptionObj) .mockingMethodCall('secondMethodName', ...) .withParameterTypes() .returning() || .throwingException() || .throwingException(ExceptionObj) .createStub() Stub Properties Name Signature Annotations mockedMethods private List<MockedMethod> mockedMethods @testVisible objectType private final Type objectType Stub Constructors Stub(objectType) required constructor finalizing the object type. Stub(objectType, mockedMethods) convenience construtor that accepts a pre-built list of MockedMethod objects. Stub() Stub(objectType) required constructor finalizing the object type. Signature public Stub(Type objectType) Parameters objectType Type: Type Type class: ie: Foo.class Stub(objectType, mockedMethods) convenience construtor that accepts a pre-built list of MockedMethod objects. Signature public Stub(Type objectType, List<MockedMethod> mockedMethods) Parameters objectType Type: Type type class: ie. Foo.class mockedMethods Type: List<MockedMethod> List of MockedMethod objects Stub() Signature return new Stub(objectType, mockedMethods) Stub Methods assertAllMockedMethodsWereCalled() Useful for asserting the methods you mocked were, in fact, called. It does this by invoking the assertMockedMethodWasCalled on each individual mocked method. createStub() returns the this constructed class with it's mocked methods as a single stub object to be used in a unit test. defineStub(generateInjectableStub) Generates a Stub object from this builder object. defineStub() handleMethodCall(obj, methodName, returnType, paramTypes, paramNames, args) method required by the StubProvider interface. Handles the mock execution of the given method call. mockingMethodCall(methodName, paramTypes) This method, and it's overloaded variants below, all work to add a new MockedMethod to the stub object. Semantically the idea is that you'll invoke one of these 'mockingMethodCall' methods for every method you want your stub to react to. Because this builder class is designed around method chaining, you can invoke a number of these in a row. See the example invocation at the top of this class. mockingMethodCall(methodName) Overloaded variant of the main 'mockingMethodCall' method. See docs for the first instance of mockingMethodCall in this class. mockingMethodCall(methodName, paramType) Overloaded variant of the main 'mockingMethodCall' method. See docs for the first instance of mockingMethodCall in this class. mockingMethodCall(methodName, paramType, paramType2) Overloaded variant of the main 'mockingMethodCall' method. See docs for the first instance of mockingMethodCall in this class. mockingMethodCall(methodName, paramType, paramType2, paramType3) Overloaded variant of the main 'mockingMethodCall' method. See docs for the first instance of mockingMethodCall in this class. mockingMethodCall(methodName, paramType, paramType2, paramType3, paramType4) Overloaded variant of the main 'mockingMethodCall' method. See docs for the first instance of mockingMethodCall in this class. assertAllMockedMethodsWereCalled() Useful for asserting the methods you mocked were, in fact, called. It does this by invoking the assertMockedMethodWasCalled on each individual mocked method. Signature public void assertAllMockedMethodsWereCalled() createStub() returns the this constructed class with it's mocked methods as a single stub object to be used in a unit test. Signature public Object createStub() Returns Object  Needs to be cast back to the type of object used. defineStub(generateInjectableStub) Generates a Stub object from this builder object. Signature public Object defineStub(Boolean generateInjectableStub) Parameters If true, calls the stub objects' createStub method automatically Returns Stub defineStub() Signature public Stub defineStub() handleMethodCall(obj, methodName, returnType, paramTypes, paramNames, args) method required by the StubProvider interface. Handles the mock execution of the given method call. Signature public Object handleMethodCall(\t\tObject obj,\t\tString methodName,\t\tType returnType,\t\tList<Type> paramTypes,\t\tList<String> paramNames,\t\tList<Object> args\t) Parameters obj Type: \t\tObject dependency injected by Apex, object the mock method was call upon methodName dependency injected by Apex, string representation of the name of the method used to construct a MethodSignature object for comparison. returnType dependency injected by Apex, not currently used. paramTypes dependency injected by Apex, list of parameter types used to construct a MethodSignature object for comparison. paramNames dependency injected by Apex, not currently used. args       dependency injected by Apex, not currently used. Returns Object mockingMethodCall(methodName, paramTypes) This method, and it's overloaded variants below, all work to add a new MockedMethod to the stub object. Semantically the idea is that you'll invoke one of these 'mockingMethodCall' methods for every method you want your stub to react to. Because this builder class is designed around method chaining, you can invoke a number of these in a row. See the example invocation at the top of this class. Signature public MethodSignature.Builder mockingMethodCall(\t\t\tString methodName,\t\t\tList<Type> paramTypes\t\t) Parameters methodName Type: \t\t\tString Required, name of the method that will be mocked paramTypes List of System.Types that the mocked method should respond to. Returns MethodSignature.Builder  - returns the builder object for chaining. mockingMethodCall(methodName) Overloaded variant of the main 'mockingMethodCall' method. See docs for the first instance of mockingMethodCall in this class. Signature public MethodSignature.Builder mockingMethodCall(String methodName) Parameters methodName Type: String Method name to be mocked. Returns MethodSignature.Builder mockingMethodCall(methodName, paramType) Overloaded variant of the main 'mockingMethodCall' method. See docs for the first instance of mockingMethodCall in this class. Signature public MockedMethod.Builder mockingMethodCall(\t\t\tString methodName,\t\t\tType paramType\t\t) Parameters methodName Type: \t\t\tString required. method name to be mocked. paramType  Type of single parameter. Returns MethodSignature.Builder mockingMethodCall(methodName, paramType, paramType2) Overloaded variant of the main 'mockingMethodCall' method. See docs for the first instance of mockingMethodCall in this class. Signature public MockedMethod.Builder mockingMethodCall(\t\t\tString methodName,\t\t\tType paramType,\t\t\tType paramType2\t\t) Parameters methodName Type: \t\t\tString required. method name to be mocked. paramType  param type 1. paramType2 param type 2. Returns MethodSignature.Builder mockingMethodCall(methodName, paramType, paramType2, paramType3) Overloaded variant of the main 'mockingMethodCall' method. See docs for the first instance of mockingMethodCall in this class. Signature public MockedMethod.Builder mockingMethodCall(\t\t\tString methodName,\t\t\tType paramType,\t\t\tType paramType2,\t\t\tType paramType3\t\t) Parameters methodName Type: \t\t\tString required. method name to be mocked. paramType  param type 1. paramType2 param type 2. paramType3 param type 3. Returns MethodSignature.Builder mockingMethodCall(methodName, paramType, paramType2, paramType3, paramType4) Overloaded variant of the main 'mockingMethodCall' method. See docs for the first instance of mockingMethodCall in this class. Signature public MockedMethod.Builder mockingMethodCall(\t\t\tString methodName,\t\t\tType paramType,\t\t\tType paramType2,\t\t\tType paramType3,\t\t\tType paramType4\t\t) Parameters methodName Type: \t\t\tString required. method name to be mocked. paramType  param type 1. paramType2 param type 2. paramType3 param type 3. paramType4 param type 4. Returns MethodSignature.Builder Stub.Builder Builder pattern for creating stubs with a fluent interface. Note, there are three 'Builder' classes, each an inner class of the object that the builder builds. In this case, this builder inner class is responsible for building Stub objects. While you can directly instantiate the Stub class, the idea is that you will actually use the Builder class/interface to create Stubs Signature public class Builder Stub.Builder Properties Name Signature Description objectType private Type objectType holds the System.Type reference for the object that you're building a stub for. Stub.Builder Constructors Builder(objType) Internally, we need to maintain a list of signature builder objects so that we can roll-up the creation of objects. Builder(objType) Internally, we need to maintain a list of signature builder objects so that we can roll-up the creation of objects. Signature public Builder(Type objType) Stub.StubException Class is used by Stub, MethodSignature and MockedMethod classes for throwing when an exception occurs that is specifically related to building, using or asserting against the Super Stub framework Signature public class StubException extends Exception"
	},
	{
		title: 'StubUtilities',
		fileName: 'StubUtilities.html',
		text: 'StubUtilities Signature @isTest public with sharing class StubUtilities StubUtilities Properties Name Signature Description counter private static Integer counter a static incrementing counter tied to transaction a new comment StubUtilities Methods generateSObjectIds(sObjectTypeString, size) Used when you want a MockedMethod to return a set of IDs of a given sObject Type generateSObjectIds(sObjectTypeString, size) Used when you want a MockedMethod to return a set of IDs of a given sObject Type Signature public static List<Id> generateSObjectIds(\t\tString sObjectTypeString,\t\tInteger size\t) Parameters sObjectTypeString Type: \t\tString Name of type: ie: Account  size              Number of valid Ids to return Returns List<Id>'
	},
	{
		title: 'TestFactory',
		fileName: 'TestFactory.html',
		text: "TestFactory Signature @isTest public class TestFactory TestFactory Properties Name Signature Description nameFieldMap private static Map<Schema.SObjectType, Schema.SObjectField> nameFieldMap When we create a list of SObjects, we need to have a unique field for the insert if there isn't an autonumber field. Usually we use the Name field, but some objects don't have a name field. TestFactory Methods addFieldDefaults(sObj, defaults) Sets field defaults on the sObj given the map of defaults. createSObject(sObj) Creates a single sObject. createSObject(sObj, doInsert) Creates a single sObject createSObject(sObj, defaultClassName) creates a single sObject createSObject(sObj, defaultClassName, doInsert) Create a single sObject createSObjectList(sObj, numberOfObjects) Creates a list of sObjects createSObjectList(sObj, numberOfObjects, doInsert) Creates a list of sObjects createSObjectList(sObj, numberOfObjects, defaultClassName, doInsert) Creates a list of sObjects createSObjectList(sObj, numberOfObjects, defaultClassName) Creates a list of sObjects addFieldDefaults(sObj, defaults) Sets field defaults on the sObj given the map of defaults. Signature private static void addFieldDefaults(\t\tSObject sObj,\t\tMap<Schema.SObjectField, Object> defaults\t) Parameters sObj Type: \t\tSObject Obj to manipulate. defaults Type: Object> Defaults map of sObjectField to Object to use for values. createSObject(sObj) Creates a single sObject. Signature public static SObject createSObject(SObject sObj) Parameters sObj Type: SObject Type of sObject to create. Returns SObject createSObject(sObj, doInsert) Creates a single sObject Signature public static SObject createSObject(SObject sObj, Boolean doInsert) Parameters sObj Type: SObject Type of sObject to create doInsert Type: Boolean Boolean should this object be inserted? Returns SObject createSObject(sObj, defaultClassName) creates a single sObject Signature public static SObject createSObject(SObject sObj, String defaultClassName) Parameters sObj Type: SObject Type of sObject to create defaultClassName Type: String Name of the class to provide field defaults Returns SObject Exceptions TestFactoryException when defaultClassName param is not a valid type. createSObject(sObj, defaultClassName, doInsert) Create a single sObject Signature public static SObject createSObject(\t\tSObject sObj,\t\tString defaultClassName,\t\tBoolean doInsert\t) Parameters sObj Type: \t\tSObject Type of sObject to create defaultClassName String name of a class providing default values doInsert         Boolean should this method insert the created object? Returns SObject createSObjectList(sObj, numberOfObjects) Creates a list of sObjects Signature public static SObject[] createSObjectList(\t\tSObject sObj,\t\tInteger numberOfObjects\t) Parameters sObj Type: \t\tSObject Type of sObjects to create numberOfObjects Integer number of objects to create Returns SObject[] createSObjectList(sObj, numberOfObjects, doInsert) Creates a list of sObjects Signature public static SObject[] createSObjectList(\t\tSObject sObj,\t\tInteger numberOfObjects,\t\tBoolean doInsert\t) Parameters sObj Type: \t\tSObject Type of sObjects to create numberOfObjects Integer number of objects to create doInsert         Boolean should this method insert the created object? Returns SObject[] createSObjectList(sObj, numberOfObjects, defaultClassName, doInsert) Creates a list of sObjects Signature public static SObject[] createSObjectList(\t\tSObject sObj,\t\tInteger numberOfObjects,\t\tString defaultClassName,\t\tBoolean doInsert\t) Parameters sObj Type: \t\tSObject Type of sObjects to create numberOfObjects Integer number of objects to create defaultClassName String name of a class providing defaults doInsert         Boolean should this method insert the created object? Returns SObject[] createSObjectList(sObj, numberOfObjects, defaultClassName) Creates a list of sObjects Signature public static SObject[] createSObjectList(\t\tSObject sObj,\t\tInteger numberOfObjects,\t\tString defaultClassName\t) Parameters sObj Type: \t\tSObject Type of sObjects to create numberOfObjects Integer number of objects to create defaultClassName String name of a class providing defaults Returns SObject[] TestFactory.FieldDefaults Use the FieldDefaults interface to set up values you want to default in for all objects Signature public interface FieldDefaults TestFactory.FieldDefaults Methods assignPermSetToUser(usr, permSetName) Assigns a permission set to a given user. createMarketingUser(doInsert) createMinAccessUser(doInsert) Creates a user with the Minimum Access Profile Relies on the previous method for creating the user. createTestUser(profileId, doInsert) creates a test user. Useful for permissions testing createTestUser(doInsert, profileName) Creates a test user with a given profile. createTestUser() createTestUser() for() getFieldDefaults() Interface used by implementing classes to define defaults. if() invalidateSObjectList(incoming) Intentionally invalidates a list of sObjects. This is useful for intentionally causing DML errors during testing. obj.put() TestFactory.createTestUser() assignPermSetToUser(usr, permSetName) Assigns a permission set to a given user. Signature public static void assignPermSetToUser(User usr, String permSetName) Parameters usr Type: User User to assign the permission set to. permSetName Type: String String name of the permission set. createMarketingUser(doInsert) Signature public static User createMarketingUser(Boolean doInsert) createMinAccessUser(doInsert) Creates a user with the Minimum Access Profile Relies on the previous method for creating the user. Signature public static User createMinAccessUser(Boolean doInsert) Parameters doInsert Type: Boolean Should this code insert the user? Returns User createTestUser(profileId, doInsert) creates a test user. Useful for permissions testing Signature public static User createTestUser(Id profileId, boolean doInsert) Parameters profileId Type: Id Profile Id to use when creating a user. doInsert Type: boolean Boolean, should this code insert the user? Returns User createTestUser(doInsert, profileName) Creates a test user with a given profile. Signature public static User createTestUser(Boolean doInsert, String profileName) Parameters doInsert Type: Boolean Should this code insert the created user? profileName Type: String Name of the profile to create the user with. Returns User createTestUser() Signature return createTestUser(selectedProfile.Id, doInsert) createTestUser() Signature return createTestUser(profileId, doInsert) for() Signature for(sObject obj : incoming) getFieldDefaults() Interface used by implementing classes to define defaults. Signature Map<Schema.SObjectField, Object> getFieldDefaults() Returns Map<Schema.SObjectField, Object> if() Signature if(doInsert) invalidateSObjectList(incoming) Intentionally invalidates a list of sObjects. This is useful for intentionally causing DML errors during testing. Signature public static List<sObject> invalidateSObjectList(List<sObject> incoming) Parameters incoming Type: List<sObject> List of SObjects Returns List<sObject> obj.put() Signature obj.put('name', '') TestFactory.createTestUser() Signature return TestFactory.createTestUser(profileId, doInsert) TestFactory.TestFactoryException Internal custom exception class Signature public class TestFactoryException extends Exception"
	}
];
